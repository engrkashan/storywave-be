
import fs from "fs";
import path from "path";
import OpenAI from "openai";
import { cloudinary } from "../config/cloudinary.config.js";
import axios from "axios";
import crypto from "crypto";
import { mergeAudioFiles } from "./audioService.js";

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

function cleanScript(script) {
  return script
    .replace(/\*\*/g, "")
    .replace(/\*/g, "")
    .replace(/\[.*?\]/g, "")
    .replace(/\(Pause\)/g, ". ")
    .trim();
}

/**  
 * üîë Generate Hume authentication header  
 */
function getHumeAuthHeaders() {
  const appId = process.env.HUME_API_KEY;
  const appSecret = process.env.HUME_SECRET_KEY;

  const timestamp = Math.floor(Date.now() / 1000).toString();
  const signature = crypto
    .createHmac("sha256", appSecret)
    .update(timestamp)
    .digest("hex");

  return {
    "X-Hume-App-Id": appId,
    "X-Hume-Time": timestamp,
    "X-Hume-Signature": signature,
  };
}

/**
 * üîä HUME TTS API CALL (FULL AUDIO BUFFER)
 */
/**
 * üîä HUME TTS API CALL (NON-STREAM)
 * Correct JSON schema
 */
async function generateHumeChunk(text, humeVoiceId) {
  const url = "https://api.hume.ai/v0/tts";

  const headers = {
    "X-Hume-Api-Key": process.env.HUME_API_KEY,
    "Content-Type": "application/json",
  };

  const body = {
    utterances: [
      {
        text,
        voice: {
          id: humeVoiceId,
        },
      },
    ],
    format: {
      type: "mp3",
    },
    num_generations: 1,
  };

  const res = await axios.post(url, body, {
    headers,
    responseType: "json",
  });

  // Base64 audio returned by Hume
  const base64Audio = res.data?.generations?.[0]?.audio;

  if (!base64Audio) {
    console.error("Unexpected Hume Response:", res.data);
    throw new Error("‚ùå No audio generated by Hume");
  }

  return Buffer.from(base64Audio, "base64");
}

/**
 * üîä OPENAI TTS CHUNK (your existing version)
 */
async function generateOpenAIChunk(text, voice) {
  const res = await openai.audio.speech.create({
    model: "tts-1",
    voice,
    input: text,
  });

  const buffer = Buffer.from(await res.arrayBuffer());
  return buffer;
}

/**
 * üéôÔ∏è Main TTS Generator (auto selects OPENAI or HUME)
 */
export async function generateVoiceover(script, filename, voiceObj, tempDir) {
  const localPath = path.join(tempDir, filename);
  fs.mkdirSync(tempDir, { recursive: true });
  const text = cleanScript(script);

  // Detect provider based on frontend payload
  const isHume = voiceObj?.provider === "hume";
  const humeVoiceId = isHume ? voiceObj.id : null;
  const openAiVoice = !isHume ? voiceObj.id : null;

  console.log(`üîä Generating voiceover using: ${isHume ? "HUME" : "OPENAI"} (${voiceObj.label})`);

  const CHUNK_SIZE = 800;
  const chunks = text.match(new RegExp(`.{1,${CHUNK_SIZE}}(\\s|$)`, "g")) || [];

  const chunkFiles = [];

  try {
    for (let i = 0; i < chunks.length; i++) {
      console.log(`üéôÔ∏è TTS chunk ${i + 1}/${chunks.length} (${isHume ? "HUME" : "OPENAI"})`);

      let buffer;

      if (isHume) {
        buffer = await generateHumeChunk(chunks[i], humeVoiceId);
      } else {
        buffer = await generateOpenAIChunk(chunks[i], openAiVoice);
      }

      const chunkPath = path.join(tempDir, `${path.parse(filename).name}_part_${i}.mp3`);
      fs.writeFileSync(chunkPath, buffer);
      chunkFiles.push(chunkPath);
    }

    // Merge chunks using ffmpeg to ensure smooth transitions
    await mergeAudioFiles(chunkFiles, localPath);

    // Cleanup temporary chunk files
    chunkFiles.forEach((file) => {
      if (fs.existsSync(file)) fs.unlinkSync(file);
    });

    // Upload to Cloudinary
    const uploadRes = await cloudinary.uploader.upload(localPath, {
      folder: "voiceovers",
      resource_type: "video",
      public_id: path.parse(filename).name,
      overwrite: true,
    });

    return { url: uploadRes.secure_url, localPath };
  } catch (err) {
    console.error("‚ùå Voiceover generation failed:", err);
    throw err;
  }
}

